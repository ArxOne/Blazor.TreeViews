@typeparam T
@inherits TreeViewBase<T>
@using Excubo.Blazor.TreeViews.__Internal

<CascadingValue Value="this" IsFixed="true">
    @if (GetParent != null)
    {
        var filtered = FilterBy(Items);
        var root_elements = filtered.Where(i => GetParent(i) == null).ToList();
        var non_root_elements = filtered.Where(i => GetParent(i) != null).ToList();
        <OrderedListByGetParent Parental="root_elements" Remaining="non_root_elements" GetParent="GetParent" />
    }
    else if (GetChildren != null)
    {
        var filtered = FilterBy(Items).ToList();
        <OrderedListByGetChildren Parental="filtered" GetChildren="GetChildren" />
    }
</CascadingValue>

@code
{
    /// <summary>
    /// The items to be displayed in the <see cref="TreeView"/>
    /// </summary>
    [Parameter] public List<T> Items { get; set; }
    /// <summary>
    /// If this parameter is set, the TreeView is populated by grouping items under their respective parent. Items which have no parent (null) are put at the top of the hierarchy.
    /// Alternatively, use <see cref="GetChildren" />.
    /// </summary>
    [Parameter] public Func<T, T> GetParent { get; set; }
    /// <summary>
    /// If this parameter is set, the TreeView is populated by all the items in Items, placing all children returned by this method under the respective item in the Items list.
    /// Alternatively, use <see cref="GetParent"/>.
    /// </summary>
    [Parameter] public Func<T, List<T>> GetChildren { get; set; }
    /// <summary>
    /// If this parameter is set, the TreeView will be populate based on the result of this method. Only works in conjunction with <see cref="GetChildren" />, not with <see cref="GetParent"/>.
    /// </summary>
    [Parameter] public Func<T, bool> HasChildren { get; set; }
    protected override void OnParametersSet()
    {
        if (HasChildren != null)
        {
            InitiallyCollapsed = true; // Collapse all if we want lazy loading, else we'll load everything at first
        }
        else
        {
            // In general case, we stay with default HasChildren behaviour
            HasChildren = item =>
            {
                var childItem = GetChildren(item);
                return childItem != null && childItem.Any();
            };
        }
        base.OnParametersSet();
    }
}
